
######################################################################################
#READ ME##############################################################################
#                                                                                    #
#This study aims to initiate different dpg functions to explore measurment invariance#
#test properties in different scenarios.Specifically,                                # 
#dgp1:different parameter, var, loading, error violate measurement invariance(MI).   #
#dgp2:model misspecified by lacking one loading, the other are the same as dgp1.     #
#dgp3:group percentage change while different parameter violate MI.                  #
#dgp4:Three groups generated by two groups violating MI with different amptitude.    #
#dgp5:Observations violate MI according to age continuously.                         # 
#dgp6 Group percentage change while 3 loading or 3 error term violate MI.            # 
######################################################################################



## Data-generating process, different dgp function represent different simulation study.
#######################################################################################
#Simualtion1, different parameter voilation############################################
dgp1 <- function(nobs = 200, diff = 3, parms="loading", perc = 0.5)
{
  # Generates data from a factor analysis model that violates
  # measurement invariance.  Also generates a continuous auxiliary
  # variable related to the invariance (loosely called "age").
  
  # ses is number of SEs between group 1's parameters and group 2's
  # parameters.
  # theta[1-6]:loadings, theta[7-12]:residual,theta[13]:covariance, theta[14-19]:mean
  sampsize <- nobs
  ses <- diff
  theta<-c(4.92,2.96,5.96,3.24,4.32,7.21,26.77,13.01,30.93,3.17,8.82,22.5,-0.48,
           29.32,24.70,14.84,10.59,19.30,18.01)
  asym<-c( 7.565818,4.951599,8.644422,3.093014,4.499676,7.368059,
            56.672724,24.255196,74.917170,8.264380,17.664706,47.093002,
           1.024326,7.139776,4.666005,8.151785,3.696972,5.242366,
            8.630417)
  # Could eventually manipulate this so break point is not directly
  # in the middle
  num.y <- round(sampsize*perc, 0)
  num.o <- sampsize - num.y
  age <- c(runif(num.y,13,16),runif(num.o,16,18))
  # Define parameter vectors/matrices:
  
  # thetas for "young" individuals:
  theta.y <- theta
  
  # thetas for "old" individuals:
  #this is the block need to change by naming different parms and assigning different vectors.
  ###################################################
  if(parms=="loading"){parmsvector=c(1,rep(0,18))}
  if(parms=="var"){parmsvector=c(rep(0,12),1,rep(0,6))}
  if(parms=="error"){parmsvector=c(rep(0,6),1,rep(0,5),rep(0,7))}
  ####################################################
  theta.o <- theta.y + (ses*asym*parmsvector/sqrt(nobs/2))  #asymptotic standard error
  
  
  lambda.y <- matrix(0,6,2)
  lambda.y[,1] <- c(theta.y[1:3],0,0,0)
  lambda.y[,2] <- c(0,0,0,theta.y[4:6])
  
  lambda.o <- matrix(0,6,2)
  lambda.o[,1] <- c(theta.o[1:3],0,0,0)
  lambda.o[,2] <- c(0,0,0,theta.o[4:6])
  
  phi.y <- matrix(theta.y[13],2,2)
  diag(phi.y) <- 1
  
  phi.o <- matrix(theta.o[13],2,2)
  diag(phi.o) <- 1
  
  psi.y <- matrix(0,6,6)
  diag(psi.y) <- theta.y[7:12]
  
  psi.o <- matrix(0,6,6)
  diag(psi.o) <- theta.o[7:12]
  
  
  mu <- theta[14:19]
  
  # Initialize data matrix:
  datmat <- matrix(0,sampsize,6)
  colnames(datmat) <- c("x1", "x2", "x3", "y1", "y2", "y3")
  
  # Generate z and u vectors:
  z.y <- t(rmvnorm(sampsize,rep(0,2),phi.y))
  z.o <- t(rmvnorm(sampsize,rep(0,2),phi.o)) 
  u.y <- t(rmvnorm(sampsize,rep(0,6),psi.y))
  u.o <- t(rmvnorm(sampsize,rep(0,6),psi.o))
  
  # Based on z and u, generate data:
  for (i in 1:num.y){
    datmat[i,] <- mu + lambda.y%*%z.y[,i] + u.y[,i]
  }
  for (i in (num.y+1):sampsize){
    datmat[i,] <- mu + lambda.o%*%z.o[,i] + u.o[,i]
  }
  cbind(as.data.frame(datmat), age)
}
###################################################################################################################################
#Simualtion2, lacking an extra loading which is theta[4]=3, different parameter voilation: extra loading, first loading,var, error#
###################################################################################################################################

dgp2 <- function(nobs = 200, diff = 3, parms="loading", perc = 0.5)
{
  # Generates data from a factor analysis model that violates
  # measurement invariance.  Also generates a continuous auxiliary
  # variable related to the invariance (loosely called "age").
  
  # ses is number of SEs between group 1's parameters and group 2's
  # parameters.
  # theta[4] is the extra loaing =3. 
  sampsize <- nobs
  ses <- diff
  theta<-c(4.92,2.96,5.96,1,3.24,4.32,7.21,26.77,13.01,30.93,3.17,8.82,22.5,-0.48,
           29.32,24.70,14.84,10.59,19.30,18.01)
  asym<-c(10.037376,4.978146,8.868835,9.009867,3.095191,4.501605,
           7.371680,60.969079,24.444897,78.555777,8.298542,17.701359,
          47.210688,1.127309,6.874096,4.666005,8.151785,3.696972,
           5.242366,8.630417)

  # Could eventually manipulate this so break point is not directly
  # in the middle
  num.y <- round(sampsize*perc, 0)
  num.o <- sampsize - num.y
  age <- c(runif(num.y,13,16),runif(num.o,16,18))
  # Define parameter vectors/matrices:
  
  # thetas for "young" individuals:
  theta.y <- theta
  
  # thetas for "old" individuals:
  #this is the block need to change by naming different parms and assigning different vectors.
  #####################################################################################
  if(parms=="extra"){parmsvector=c(rep(0,3),1,rep(0,3),rep(0,6),0,rep(0,6))}
  if(parms=="extra+loading"){parmsvector=c(1,rep(0,2),0,rep(0,3),rep(0,6),0,rep(0,6))}
  if(parms=="extra+var"){parmsvector=c(rep(0,3),0,rep(0,3),rep(0,6),1,rep(0,6))}
  if(parms=="extra+error"){parmsvector=c(rep(0,3),0,rep(0,3),1,rep(0,5),0,rep(0,6))}
  #####################################################################################
  theta.o <- theta.y + (ses*asym*parmsvector/sqrt(nobs/2))  #asymptotic standard error
  
  
  lambda.y <- matrix(0,6,2)
  lambda.y[,1] <- c(theta.y[1:3],0,0,0)
  lambda.y[,2] <- c(theta.y[4],0,0,theta.y[5:7])
  
  lambda.o <- matrix(0,6,2)
  lambda.o[,1] <- c(theta.o[1:3],0,0,0)
  lambda.o[,2] <- c(theta.o[4],0,0,theta.o[5:7])
  
  phi.y <- matrix(theta.y[14],2,2)
  diag(phi.y) <- 1
  
  phi.o <- matrix(theta.o[14],2,2)
  diag(phi.o) <- 1
  
  psi.y <- matrix(0,6,6)
  diag(psi.y) <- theta.y[8:13]
  
  psi.o <- matrix(0,6,6)
  diag(psi.o) <- theta.o[8:13]
  
  
  mu <- theta[15:20]
  
  # Initialize data matrix:
  datmat <- matrix(0,sampsize,6)
  colnames(datmat) <- c("x1", "x2", "x3", "y1", "y2", "y3")
  
  # Generate z and u vectors:
  z.y <- t(rmvnorm(sampsize,rep(0,2),phi.y))
  z.o <- t(rmvnorm(sampsize,rep(0,2),phi.o)) 
  u.y <- t(rmvnorm(sampsize,rep(0,6),psi.y))
  u.o <- t(rmvnorm(sampsize,rep(0,6),psi.o))
  
  # Based on z and u, generate data:
  for (i in 1:num.y){
    datmat[i,] <- mu + lambda.y%*%z.y[,i] + u.y[,i]
  }
  for (i in (num.y+1):sampsize){
    datmat[i,] <- mu + lambda.o%*%z.o[,i] + u.o[,i]
  }
  cbind(as.data.frame(datmat), age)
}

######################################################################################
#Simualtion3, different percentage of voilation############################################
dgp3 <- function(nobs = 200, diff = 3, parms = "loading", perc = 0.5)
{
  # Generates data from a factor analysis model that violates
  # measurement invariance.  Also generates a continuous auxiliary
  # variable related to the invariance (loosely called "age").
  
  # ses is number of SEs between group 1's parameters and group 2's
  # parameters.
  # theta[1-6]:loadings, theta[7-12]:residual,theta[13]:covariance, theta[14-19]:mean
  sampsize <- nobs
  ses <- diff
  theta<-c(4.92,2.96,5.96,3.24,4.32,7.21,26.77,13.01,30.93,3.17,8.82,22.5,-0.48,
           29.32,24.70,14.84,10.59,19.30,18.01)
  asym<-c( 7.565818,4.951599,8.644422,3.093014,4.499676,7.368059,
            56.672724,24.255196,74.917170,8.264380,17.664706,47.093002,
           1.024326,7.139776,4.666005,8.151785,3.696972,5.242366,
            8.630417)
  
  # Could eventually manipulate this so break point is not directly
  # in the middle
  num.y <- round(sampsize*perc, 0)
  num.o <- sampsize - num.y
  age <- c(runif(num.y,13,16),runif(num.o,16,18))
  # Define parameter vectors/matrices:
  
  # thetas for "young" individuals:
  theta.y <- theta
  
  # thetas for "old" individuals:
  #this is the block need to change by naming different parms and assigning different vectors.
  ###################################################
  if(parms=="loading"){parmsvector=c(1,rep(0,18))}
  if(parms=="var"){parmsvector=c(rep(0,12),1,rep(0,6))}
  if(parms=="error"){parmsvector=c(rep(0,6),1,rep(0,5),rep(0,7))}
  ####################################################
  theta.o <- theta.y + (ses*asym*parmsvector/sqrt(nobs/2))  #asymptotic standard error
  
  
  lambda.y <- matrix(0,6,2)
  lambda.y[,1] <- c(theta.y[1:3],0,0,0)
  lambda.y[,2] <- c(0,0,0,theta.y[4:6])
  
  lambda.o <- matrix(0,6,2)
  lambda.o[,1] <- c(theta.o[1:3],0,0,0)
  lambda.o[,2] <- c(0,0,0,theta.o[4:6])
  
  phi.y <- matrix(theta.y[13],2,2)
  diag(phi.y) <- 1
  
  phi.o <- matrix(theta.o[13],2,2)
  diag(phi.o) <- 1
  
  psi.y <- matrix(0,6,6)
  diag(psi.y) <- theta.y[7:12]
  
  psi.o <- matrix(0,6,6)
  diag(psi.o) <- theta.o[7:12]
  
  
  mu <- theta[14:19]
  
  # Initialize data matrix:
  datmat <- matrix(0,sampsize,6)
  colnames(datmat) <- c("x1", "x2", "x3", "y1", "y2", "y3")
  
  # Generate z and u vectors:
  z.y <- t(rmvnorm(sampsize,rep(0,2),phi.y))
  z.o <- t(rmvnorm(sampsize,rep(0,2),phi.o)) 
  u.y <- t(rmvnorm(sampsize,rep(0,6),psi.y))
  u.o <- t(rmvnorm(sampsize,rep(0,6),psi.o))
  
  # Based on z and u, generate data:
  for (i in 1:num.y){
    datmat[i,] <- mu + lambda.y%*%z.y[,i] + u.y[,i]
  }
  for (i in (num.y+1):sampsize){
    datmat[i,] <- mu + lambda.o%*%z.o[,i] + u.o[,i]
  }
  cbind(as.data.frame(datmat), age)
}

######################################################################################
#Simualtion4, multiple groups are generated############################################
dgp4 <- function(nobs = 200, diff = 3, parms="loading", perc = 1/3)
{
  # Generates data from a factor analysis model that violates
  # measurement invariance.  Also generates a continuous auxiliary
  # variable related to the invariance (loosely called "age").
  
  # ses is number of SEs between group 1's parameters and group 2's
  # parameters.
  # theta[1-6]:loadings, theta[7-12]:residual,theta[13]:covariance, theta[14-19]:mean
 sampsize <- nobs
  ses <- diff
  theta<-c(4.92,2.96,5.96,3.24,4.32,7.21,26.77,13.01,30.93,3.17,8.82,22.5,-0.48,
           29.32,24.70,14.84,10.59,19.30,18.01)
  asym<-c( 7.565818,4.951599,8.644422,3.093014,4.499676,7.368059,
            56.672724,24.255196,74.917170,8.264380,17.664706,47.093002,
           1.024326,7.139776,4.666005,8.151785,3.696972,5.242366,
            8.630417)
  
  # Could eventually manipulate this so break point is not directly
  # in the middle
  num.y <- round(sampsize*perc, 0)
  num.a <- round(sampsize*perc, 0)
  num.o <- sampsize - num.y- num.a
  age <- c(runif(num.y,13,15),runif(num.o,15,16),runif(num.a,16,18))
  # Define parameter vectors/matrices:
  
  # thetas for "young" individuals:
  theta.y <- theta
 
  
  # thetas for "old" individuals:
  #this is the block need to change by naming different parms and assigning different vectors.
  ###################################################
  if(parms=="loading"){parmsvector=c(1,rep(0,18))}
  if(parms=="var"){parmsvector=c(rep(0,12),1,rep(0,6))}
  if(parms=="error"){parmsvector=c(rep(0,6),1,rep(0,5),rep(0,7))}
  ####################################################
  theta.o <- theta.y + (ses/2*asym*parmsvector/sqrt(nobs/2))  #asymptotic standard error
  theta.a <- theta.y + (ses*asym*parmsvector/sqrt(nobs/2))  #asymptotic standard error
  
  lambda.y <- matrix(0,6,2)
  lambda.y[,1] <- c(theta.y[1:3],0,0,0)
  lambda.y[,2] <- c(0,0,0,theta.y[4:6])
  
  lambda.o <- matrix(0,6,2)
  lambda.o[,1] <- c(theta.o[1:3],0,0,0)
  lambda.o[,2] <- c(0,0,0,theta.o[4:6])

  lambda.a <- matrix(0,6,2)
  lambda.a[,1] <- c(theta.a[1:3],0,0,0)
  lambda.a[,2] <- c(0,0,0,theta.a[4:6])
  
  phi.y <- matrix(theta.y[13],2,2)
  diag(phi.y) <- 1
  
  phi.o <- matrix(theta.o[13],2,2)
  diag(phi.o) <- 1

  phi.a <- matrix(theta.a[13],2,2)
  diag(phi.a) <- 1
  
  psi.y <- matrix(0,6,6)
  diag(psi.y) <- theta.y[7:12]
  
  psi.o <- matrix(0,6,6)
  diag(psi.o) <- theta.o[7:12]

  psi.a <- matrix(0,6,6)
  diag(psi.a) <- theta.a[7:12]
  
  
  mu <- theta[14:19]
  
  # Initialize data matrix:
  datmat <- matrix(0,sampsize,6)
  colnames(datmat) <- c("x1", "x2", "x3", "y1", "y2", "y3")
  
  # Generate z and u vectors:
  z.y <- t(rmvnorm(sampsize,rep(0,2),phi.y))
  z.o <- t(rmvnorm(sampsize,rep(0,2),phi.o))
  z.a <- t(rmvnorm(sampsize,rep(0,2),phi.a))
  u.y <- t(rmvnorm(sampsize,rep(0,6),psi.y))
  u.o <- t(rmvnorm(sampsize,rep(0,6),psi.o))
  u.a <- t(rmvnorm(sampsize,rep(0,6),psi.a))
  
  # Based on z and u, generate data:
  for (i in 1:num.y){
    datmat[i,] <- mu + lambda.y%*%z.y[,i] + u.y[,i]
  }
  for (i in (num.y+1):(num.y+1+num.a)){
    datmat[i,] <- mu + lambda.a%*%z.a[,i] + u.a[,i]
  }
  for (i in (num.y+1+num.a+1):sampsize){
    datmat[i,] <- mu + lambda.o%*%z.o[,i] + u.o[,i]
  }
  cbind(as.data.frame(datmat), age)
}
  
 

######################################################################################
dgp5 <- function(nobs = 200, diff = 3, parms="loading",perc=1)
{
  # Generates data from a factor analysis model that violates
  # measurement invariance.  Also generates a continuous auxiliary
  # variable related to the invariance (loosely called "age").
  
  # ses is number of SEs between group 1's parameters and group 2's
  # parameters.
  # theta[1-6]:loadings, theta[7-12]:residual,theta[13]:covariance, theta[14-19]:mean
  sampsize <- nobs
  ses <- diff
  theta<-c(4.92,2.96,5.96,3.24,4.32,7.21,26.77,13.01,30.93,3.17,8.82,22.5,-0.48,
           29.32,24.70,14.84,10.59,19.30,18.01)
  asym<-c( 7.565818,4.951599,8.644422,3.093014,4.499676,7.368059,
            56.672724,24.255196,74.917170,8.264380,17.664706,47.093002,
           1.024326,7.139776,4.666005,8.151785,3.696972,5.242366,
            8.630417)
  age <- c(runif(sampsize,13,18))
  z.age<-scale(age)

  # Initialize data matrix:
  datmat <- matrix(0,sampsize,6)
  colnames(datmat) <- c("x1", "x2", "x3", "y1", "y2", "y3")
 
  
  # Define parameter vectors/matrices:  
 
  #this is the block need to change by naming different parms and assigning different vectors.
  ###################################################
  if(parms=="loading"){parmsvector=c(1,rep(0,18))}
  if(parms=="var"){parmsvector=c(rep(0,12),1,rep(0,6))}
  if(parms=="error"){parmsvector=c(rep(0,6),1,rep(0,5),rep(0,7))}
  ####################################################
  theta.age <- matrix(0,sampsize,length(theta))
  
  
  for (i in 1:sampsize){
  theta.age[i,] <- theta + diff*asym*z.age[i]*parmsvector/sqrt(nobs/2)*perc 

  lambda <- matrix(0,6,2)
  
  lambda[,1]<- c(theta.age[i,1:3],0,0,0)
  lambda[,2] <- c(0,0,0,theta.age[i,4:6])


  phi <- matrix(theta.age[i,13],2,2)
  diag(phi) <- 1
  

  psi <- matrix(0,6,6)
  diag(psi) <- theta.age[i,7:12]

  mu <- theta.age[i,14:19]

  # Generate z and u vectors:

  z <- t(rmvnorm(sampsize,rep(0,2),phi)) 
  u <- t(rmvnorm(sampsize,rep(0,6),psi))
 
  # Based on z and u, generate data:
  datmat[i,] <- mu + lambda %*%z[,i] + u[,i]
  }
  cbind(as.data.frame(datmat), z.age)
}

######################################################################################
#Simualtion6, different percentage of voilation############################################
dgp6 <- function(nobs = 200, diff = 3, parms = "loading", perc = 0.5)
{
  # Generates data from a factor analysis model that violates
  # measurement invariance.  Also generates a continuous auxiliary
  # variable related to the invariance (loosely called "age").
  
  # ses is number of SEs between group 1's parameters and group 2's
  # parameters.
  # theta[1-6]:loadings, theta[7-12]:residual,theta[13]:covariance, theta[14-19]:mean
  sampsize <- nobs
  ses <- diff
  theta<-c(4.92,2.96,5.96,3.24,4.32,7.21,26.77,13.01,30.93,3.17,8.82,22.5,-0.48,
           29.32,24.70,14.84,10.59,19.30,18.01)
  asym<-c( 7.565818,4.951599,8.644422,3.093014,4.499676,7.368059,
            56.672724,24.255196,74.917170,8.264380,17.664706,47.093002,
           1.024326,7.139776,4.666005,8.151785,3.696972,5.242366,
            8.630417)
  
  # Could eventually manipulate this so break point is not directly
  # in the middle
  num.y <- round(sampsize*perc, 0)
  num.o <- sampsize - num.y
  age <- c(runif(num.y,13,16),runif(num.o,16,18))
  # Define parameter vectors/matrices:
  
  # thetas for "young" individuals:
  theta.y <- theta
  
  # thetas for "old" individuals:
  #this is the block need to change by naming different parms and assigning different vectors.
  ###################################################
  if(parms=="loading"){parmsvector=c(1,1,1,rep(0,16))}
  if(parms=="error"){parmsvector=c(rep(0,6),1,1,1,rep(0,3),rep(0,7))}
  ####################################################
  theta.o <- theta.y + (ses*asym*parmsvector/sqrt(nobs/2))  #asymptotic standard error
  
  
  lambda.y <- matrix(0,6,2)
  lambda.y[,1] <- c(theta.y[1:3],0,0,0)
  lambda.y[,2] <- c(0,0,0,theta.y[4:6])
  
  lambda.o <- matrix(0,6,2)
  lambda.o[,1] <- c(theta.o[1:3],0,0,0)
  lambda.o[,2] <- c(0,0,0,theta.o[4:6])
  
  phi.y <- matrix(theta.y[13],2,2)
  diag(phi.y) <- 1
  
  phi.o <- matrix(theta.o[13],2,2)
  diag(phi.o) <- 1
  
  psi.y <- matrix(0,6,6)
  diag(psi.y) <- theta.y[7:12]
  
  psi.o <- matrix(0,6,6)
  diag(psi.o) <- theta.o[7:12]
  
  
  mu <- theta[14:19]
  
  # Initialize data matrix:
  datmat <- matrix(0,sampsize,6)
  colnames(datmat) <- c("x1", "x2", "x3", "y1", "y2", "y3")
  
  # Generate z and u vectors:
  z.y <- t(rmvnorm(sampsize,rep(0,2),phi.y))
  z.o <- t(rmvnorm(sampsize,rep(0,2),phi.o)) 
  u.y <- t(rmvnorm(sampsize,rep(0,6),psi.y))
  u.o <- t(rmvnorm(sampsize,rep(0,6),psi.o))
  
  # Based on z and u, generate data:
  for (i in 1:num.y){
    datmat[i,] <- mu + lambda.y%*%z.y[,i] + u.y[,i]
  }
  for (i in (num.y+1):sampsize){
    datmat[i,] <- mu + lambda.o%*%z.o[,i] + u.o[,i]
  }
  cbind(as.data.frame(datmat), z.age)
}


#############################################################################################
## Evaluate power simulation on a single dgp() scenario
#1to6  indicate six loadings
#7to12  indicate six errors
#14to19 indicate six means
#13 indicate all parameters except intercepts
#1,2,...19 indicate 19 parmaters respectively

testpower <- function(nrep = 5000, size = 0.05, sim="sim1", test = test, parnum = parnum, verbose = TRUE, ...)
{
  pval <- matrix(rep(NA,length(test) * nrep), ncol = length(test))
  ## Condensed
  colnames(pval) <- test
  dfun <- paste("dgp", substr(sim,4,4), sep="")

  for(i in 1:nrep) {
    ## Condensed
    d <- do.call(dfun, list(...))

    mz <- mzfit(d)

    ## Condensed
    mz_gefp <- vector("list", length(parnum))
    for(j in 1:length(parnum)){
        mz_gefp[[j]] <- try(gefp(mz, fit = NULL, vcov = info.mzfit,
                                 order.by = d$age, sandwich = FALSE,
                                 parm = eval(parse(text=parnum[j]))),
                            silent = TRUE)

        if(!inherits(mz_gefp[[j]], "try-error")) {
            pval[i, (j-1)*3 + 1] <- sctest(mz_gefp[[j]],  functional = maxBB)$p.value
            pval[i, (j-1)*3 + 2] <- sctest(mz_gefp[[j]],  functional = meanL2BB)$p.value
            pval[i, (j-1)*3 + 3] <- sctest(mz_gefp[[j]],  functional = supLM(0.1))$p.value
        }
    }
  }
  rval <- colMeans(pval < size, na.rm = TRUE)
  if(verbose) print(rval)
  
  return(rval)
}



## Loop over scenarios
simulation <- function(diff = seq(0, 4, by = 0.25), parms="error", perc=0.5,
                       nobs = c(50,100,200,500), verbose = TRUE, ...)
{
  prs <- expand.grid(diff = diff, nobs = nobs, parms = parms, perc = perc)
  nprs <- nrow(prs)

  parnum <- c(1,7,13,"1:6","7:12")

  tname <- c("dmax","CvM","supLM")
  ## Condensed:
  test <- paste(rep(tname,length(parnum)), rep(parnum, each=length(tname)),
                sep="")
  ntest <- length(test)
  
  pow <- matrix(rep(NA, ntest * nprs), ncol = ntest)

  do.parallel <- require("parallel")
  if (do.parallel){
    pow <- mclapply(1:nprs, function(i){
      testpower(diff = prs$diff[i], nobs = prs$nobs[i],
                parms = prs$parms[i],perc = prs$perc[i],
                parnum = parnum, test = test, verbose = verbose, ...)},
                    mc.cores = round(.75*detectCores()),
                    mc.preschedule = FALSE)
    pow <- t(matrix(unlist(pow), ntest, nprs))
  } else {
    for(i in 1:nprs) {
      if(verbose) print(prs[i,])
      pow[i,] <- testpower(diff = prs$diff[i], nobs = prs$nobs[i],
                           parms = prs$parms[i],
                           perc = prs$perc[i], parnum = parnum,
                           test = test, verbose = verbose, ...)
    }
  }
  
  rval <- data.frame()
  for(i in 1:ntest) rval <- rbind(rval, prs)
  ## Condensed these two:
  rval$test <- factor(rep(rep(tname,length(parnum)), each=nprs),
                      levels = c("dmax", "CvM", "supLM"))
  rval$pars <- factor(rep(rep(parnum, each=length(tname)), each=nprs),
                          levels = parnum)
  
  rval$nobs <- factor(rval$nobs)
  rval$perc <- factor(rval$perc)
  rval$power <- as.vector(pow)
  return(rval)
}

## RUN THE SIMULATION
if(FALSE) {  ## Ignore this line, it just tells R to ignore this code:
  ## code and packages

  library("lavaan")
  library("strucchange")
  library("mvtnorm")
  source("mz.R")  ## Model code
  source("simall.R")  ## Simulation code
  source("estfun.working.R")  ## Score extraction code
  
  
  ## seed for replication
  RNGkind(kind = "default", normal.kind = "default")
  set.seed(1090)
  
  ## run simulation
  ## sim_# <- simulation()
  
  ## To get a shorter version (say, 20 minutes)to see what's going on, you could do:
  sim1 <- simulation(sim=c("sim1"), nobs=c(100,500),nrep=300, diff = c(2,4),
                     parms=c("loading"),perc=0.5)
  sim2 <- simulation(sim=c("sim2"), nobs=c(100,500),nrep=300, diff = c(2,4),
                     parms=c("extra","extra+loading","extra+var","extra+error"),
                     perc=0.5)
  sim3 <- simulation(sim=c("sim3"), nobs=c(100,500),nrep=300, diff = c(2,4),
                     parms=c("loading","var","error"),perc=c(0.1,0.25,0.5,0.75,0.9))
  sim4 <- simulation(sim=c("sim4"), nobs=c(100,500),nrep=300, diff=seq(2,4),parms=c("loading",
                     "var","error"),perc=0.5)
  sim5 <- simulation(sim=c("sim5"), nobs=500,nrep=300,diff=100,
                     parms=c("loading"),perc=1)
  sim6 <- simulation(sim=c("sim6"), nobs=c(100,500),nrep=300, diff = c(2,4),
                     parms=c("loading","error"),perc=c(0.1,0.25,0.5,0.75,0.9))

  ## full simulation:
  sim1 <- simulation(sim=c("sim1"), nobs=c(100,200,500), diff=seq(0,4,.25), parms=
                     c("loading","var","error"))
  sim2 <- simulation(sim=c("sim2"), nobs=c(100,200,500), diff=seq(0,4,.25),
                     parms=c("extra","extra+loading","extra+var","extra+error"))
  sim3 <- simulation(sim=c("sim3"), nobs=500, diff=seq(0,4,.25), parms=c("loading","var","error"),
                     perc=seq(0.05,0.95,0.05))
  sim4 <- simulation(sim=c("sim4"), nobs=c(100,200,500), diff=seq(0,4,.25),
                     parms=c("loading","var","error"),perc=1/3)
 # sim5 <- simulation(sim=c("sim5"), nobs=c(100,200,500),diff=seq(10,100,5),
 #                    parms=c("loading","error"))
  sim6 <- simulation(sim=c("sim6"), nobs=500, diff=seq(0,4,.25), parms=c("loading","error"),
                     perc=seq(0.05,0.95,0.05))
  
  save(sim1, file = "sim1.rda")
  save(sim2, file = "sim2.rda")
  save(sim3, file = "sim3.rda")
  save(sim4, file = "sim4.rda")
  save(sim5, file = "sim5.rda")
  save(sim6, file = "sim6.rda")
################################################################################################################
  ## sim1 results
  ## load simulation results
  load("sim1.rda")
  
  ## display result in graphic
  library(lattice)
  library(graphics)
  trellis.par.set(theme = canonical.theme(color = FALSE))
  ## all
  postscript("sim1.pdf")
  mykey1 <- simpleKey(unique(sim1$test), points = TRUE, lines = TRUE)
  xyplot(power ~ diff | pars + nobs + parms, group = ~ test,
         data = sim1, subset = diff %in% c(seq(0, 4, by = 0.5)),type = "b",
         xlab="Violation Magnitude", ylab="Power")
  args.list <- c(xyplot,list(nrow=6,ncol=7))
  dev.off()

#################################################################################################################
 ## sim2 results
 ## load simulation results
  load("sim2.rda")
  
  ## display result in graphic
  library(lattice)
  library(graphics)
  trellis.par.set(theme = canonical.theme(color = FALSE))
  ## all
  postscript("sim2.pdf")
  xyplot(power ~ diff | pars + nobs + parms, group = ~ test,
         data = sim2, subset = diff %in% c(seq(0, 4, by = 0.5)),type = "b",
         xlab="Violation Magnitude", ylab="Power")
  args.list <- c(xyplot,list(nrow=6,ncol=7))
  dev.off()

  
#######################################################################################################################

  ## sim3 results
  ## load simulation results
  load("sim3.rda")
  
  ## display result in graphic
  library(lattice)
  library(graphics)
  trellis.par.set(theme = canonical.theme(color = FALSE))
  ## all
  postscript("sim3.pdf")
  xyplot(power ~ diff | pars + nobs + parms + perc, group = ~ test,
         data = sim3, subset = diff %in% c(seq(0, 4, by = 0.5)),type = "b",
         xlab="Violation Magnitude", ylab="Power")
  args.list <- c(xyplot,list(nrow=6,ncol=7))
  dev.off()

#######################################################################################################################
 ## sim4 results
  ## load simulation results
  load("sim4.rda")
  
  ## display result in graphic
  library(lattice)
  library(graphics)
  trellis.par.set(theme = canonical.theme(color = FALSE))
  ## all
  postscript("sim4.pdf")
  xyplot(power ~ diff | pars + nobs + parms + perc, group = ~ test,
         data = sim4, subset = diff %in% c(seq(0, 4, by = 0.5)),type = "b",
         xlab="Violation Magnitude", ylab="Power")
  args.list <- c(xyplot,list(nrow=6,ncol=7))
  dev.off()
  #######################################################################################################################
 ## sim5 results
  ## load simulation results
  load("sim5.rda")
  
  ## display result in graphic
  library(lattice)
  library(graphics)
  trellis.par.set(theme = canonical.theme(color = FALSE))
  ## all
  postscript("sim5.pdf")
  xyplot(power ~ diff | pars + nobs + parms + perc, group = ~ test,
         data = sim5,type = "b",
         xlab="Violation Magnitude", ylab="Power")
  args.list <- c(xyplot,list(nrow=6,ncol=7))
  dev.off()
  

  #######################################################################################################################
 ## sim6 results
  ## load simulation results
  load("sim6.rda")
  
  ## display result in graphic
  library(lattice)
  library(graphics)
  trellis.par.set(theme = canonical.theme(color = FALSE))
  ## all
  postscript("sim6.pdf")
  mykey6 <- simpleKey(unique(sim6$test), points = TRUE, lines = TRUE)
  xyplot(power ~ diff | pars + nobs + parms + perc, group = ~ test,
         data = sim6, subset = diff %in% c(seq(0, 4, by = 0.5)),type = "b",
         xlab="Violation Magnitude", ylab="Power",key=mykey6)
  args.list <- c(xyplot,list(nrow=6,ncol=7))
  dev.off()

  
}

 


